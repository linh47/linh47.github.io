{"meta":{"title":"小哀的安眠岛","subtitle":"想要听你说 你看见的光 是我","description":null,"author":"Linh","url":"https://linh47.github.io","root":"/"},"pages":[{"title":"categories","date":"2019-03-13T06:17:44.000Z","updated":"2019-03-13T07:06:42.444Z","comments":true,"path":"categories/index.html","permalink":"https://linh47.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于我 About me?Who cares;）","date":"2019-03-13T05:37:23.000Z","updated":"2019-03-18T14:40:06.181Z","comments":true,"path":"about/index.html","permalink":"https://linh47.github.io/about/index.html","excerpt":"","text":"你好啊，居然能在茫茫网络中发现这个小小博客，你真是厉害呢！ 我是谁呢？​ 叫我小哀就行，目前2017-2020中南大学计算机研究生在读。女的。 ​ 研究方向是：推荐算法+复杂网络。 这个博客干嘛的呢？ 我觉得值得分享的内容，会以认真的态度整理并发在这里。 ​ 主要包括Java相关内容，学术研究有关内容，新技能开发，好用物品推荐。 写博客的初衷是： ​ 热爱并拥护程序员的开源精神。我受益于此，也想做一份小小贡献。 ​ 豆瓣里豆油的日记给我的启发也非常多，希望我能好好写东西，记录一下成长吧。 如果你有什么问题可以发邮件给我，联系邮箱：linh47@163.com 我没有斜杠，不太擅长给自己贴标签。日常BB在豆瓣，并不文艺，是个随心所欲的家伙。 人生要义是开心。希望你过得越来越好。 ——————————English Version 相当正经的介绍；)—————————— Hello.Welcome to linh’s blog.I’m a 24 year-old girl (it doesn’t mean anything, but there are always someone think I’m a boy). I am a graduate student in computer science at Central South University,and I will graduate in June 2020.By the way,Central South University is located in Changsha, China. My research area is recommendation algorithms and complex networks. This blog is designed to share my personal insights, including Java articles, understanding of academic research papers, ways to develop new skills, and what I like most recently. If you are interested in my computer science articles and want to get resources and codes, you can follow me on github. The link is https://github.com/linh47. If you would like to contact me, please send an email to linh47@163.com. I hope you have a wonderful day. ；）"}],"posts":[{"title":"【面试题解析】Java 多线程","slug":"【面试题解析】Java 多线程","date":"2019-03-31T08:03:34.000Z","updated":"2019-03-31T08:12:14.856Z","comments":true,"path":"2019/03/31/【面试题解析】Java 多线程/","link":"","permalink":"https://linh47.github.io/2019/03/31/【面试题解析】Java 多线程/","excerpt":"","text":"1、多线程中的i++线程安全吗？为什么？ 答案： 不安全， ①i++操作不是原子性的，它分为三步，读取i的值，对i的值加1，把结果赋值给i++，这三步中任意一步都可能被其他线程抢占。 ②把i设置成volatile也不能保证i++是原子性的，volatile只能保证可见性，即变量在读的时候是内存可见的，但是不能保证操作的原子性，即这几步操作其他线程不抢占。 ③可以通过使用concurrent包里的原子类来使i++变成线程安全的计数器，比如说int类型可以使用AtomicInteger类。因为这些类的底层是由Java的unsafe实现的，可以保证线程安全。 2、如何线程安全地实现一个计数器？ 答案： ①使用加锁，比如synchronized或者lock 例子： 1234567891011public class AtomicCounter &#123; private volatile int count = 0; public synchronized void increment() &#123; count++; &#125; public int getCount() &#123; return count; &#125; &#125; ②也可以使用concurrent包下的原子类 1234567891011public class AtomicCounter &#123; private AtomicInteger count = new AtomicInteger(); public void increment() &#123; count.incrementAndGet(); &#125; public int getCount() &#123; return count.get(); &#125; &#125; 3、多线程同步的方法 时间换空间 ①synchronized：使用synchronized修饰的方法或者代码块可以看成是一个原子操作。 方法：用this锁住整个方法内的代码块，如果是静态方法就锁了整个类。 1234567public synchronized void output(String name)&#123; for(int i = 0; i &lt; name.length(); i++) &#123; System.out.print(name.charAt(i)); &#125; &#125; 代码块：共享对象作为锁，将需要互斥的代码包含起来 12345678&#123; synchronized (this) &#123; for(int i = 0; i &lt; name.length(); i++) &#123; System.out.print(name.charAt(i)); &#125; &#125; &#125; synchronized关键字既保证了多线程的并发有序性，又保证了多线程的内存可见性。 ②lock（接口） 使用ReentrantLock类（可重入、互斥、实现了Lock接口） 可重入意为迭代的时候不会出现死锁。 ③volatile 保证内存可见性，不保证操作原子性。 要使 volatile 变量提供理想的线程安全，必须同时满足下面两个条件： ​ 1、对变量的写操作不依赖于当前值。 ​ 2、该变量没有包含在具有其他变量的不变式中。 空间换时间 ④ThreadLocal 每个线程获得一个实例的副本，互不影响。线程持有一个Map，里面保存对象的映射。 实际上不存在同步的问题，因为没有共享资源。 另一种方法： ⑤Semaphore信号量 适用于多线程、多任务的场景，用信号量对资源进行访问控制，限制访问共享资源的线程数。使用信号量不会保证线程安全，因此，在访问的时候，要自己控制线程的安全访问。 信号量提供了了一种很方便的方法来保证对共享变量的互斥访问，基本思想是 将每个共享变量（或一组相关的共享变量）与一个信号量 s （初始化为1）联系起来，然后用 wait/signal 操作将相应的临界区包围起来。 二元信号量也被称为互斥锁（mutex，mutual exclusve, 也称为 binary semaphore），wait 操作相当于加锁，signal 相当于解锁。 Lock解决的问题： 1）可以不让等待的线程一直无期限地等待下去 或者 能够响应中断； 2）当多个线程都只是进行读操作时，线程之间不会发生冲突； 3）得知线程有没有成功获取到锁。 synchronized与lock区别 ​ (1) Lock是一个接口，是JDK层面的实现；而synchronized是Java中的关键字，是Java的内置特性，是JVM层面的实现； ​ (2) synchronized 在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁； ​ (3) Lock 可以让等待锁的线程响应中断，而使用synchronized时，等待的线程会一直等待下去，不能够响应中断； ​ (4) 通过Lock可以知道有没有成功获取锁，而synchronized却无法办到； ​ (5) Lock可以提高多个线程进行读操作的效率。 在性能上来说，如果竞争资源不激烈，两者的性能是差不多的。 而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。 4、介绍一下生产者消费者模式？ 答案： 生产者消费者模式是一个多线程并发协作的模式。将线程分为两类，生产者和消费者，他们通过共享的内存缓冲区进行通信。生产者线程负责产生数据放到内存缓冲区里，消费者线程从内存缓冲区中取出数据。 使用生产者消费者模式的好处： 能够解耦生产者和消费者，他们彼此之间不直接依赖。生产者产生数据不需要依赖消费者的处理速度，消费者不能及时处理的又可以暂存在缓冲区。 共享数据区域中应该具备这样的线程间并发协作的功能： 如果共享数据区已满的话，阻塞生产者继续生产数据放置入内； 如果共享数据区为空的话，阻塞消费者继续消费数据； 实现这种模式有3种方法。 ①BlockingQueue阻塞队列 阻塞队列完全可以充当共享数据区域 ②Object的wait/notify消息通知机制 在Object提供的消息通知机制应该遵循如下这些条件： 永远在while循环中对条件进行判断而不是if语句中进行wait条件的判断； 使用NotifyAll而不是使用notify。 ③Lock中Condition的await/signal机制 跟wait/notify差不多 在使用线程的等待/通知机制时，一般都要在 while 循环中调用 wait()方法，因此配合使用一个 boolean 变量（或其他能判断真假的条件，如本文中的 list.isEmpty()），满足 while 循环的条件时，进入 while 循环，执行 wait()方法，不满足 while 循环的条件时，跳出循环，执行后面的代码。 5、创建线程有很大的开销，怎么优化？","categories":[{"name":"computer science计算机技术","slug":"computer-science计算机技术","permalink":"https://linh47.github.io/categories/computer-science计算机技术/"},{"name":"Java","slug":"computer-science计算机技术/Java","permalink":"https://linh47.github.io/categories/computer-science计算机技术/Java/"}],"tags":[{"name":"-Java SE - 面试题","slug":"Java-SE-面试题","permalink":"https://linh47.github.io/tags/Java-SE-面试题/"}]},{"title":"【面试题解析】Java SE","slug":"【面试题解析】Java SE","date":"2019-03-31T08:01:53.000Z","updated":"2019-03-31T08:11:44.385Z","comments":true,"path":"2019/03/31/【面试题解析】Java SE/","link":"","permalink":"https://linh47.github.io/2019/03/31/【面试题解析】Java SE/","excerpt":"","text":"1、重写equals()时为什么也得重写hashCode()？ 答案： 前置问题：为什么要重写equals方法？ 从超类Object继承而来的equals方法与‘==’是完全等价的，比较的都是对象的内存地址，但我们可以重写equals方法，使其按照我们的需求的方式进行比较，如String类重写了equals方法，使其比较的是字符的序列，而不再是内存地址。 前置问题：hashCode()的作用？ Map接口的类会使用到键对象的哈希码。在java中，我们可以使用hashCode()来获取对象的哈希码，其值就是对象的存储地址，这个方法在Object类中声明，因此所有的子类都含有该方法。如果x与y是两个不同的对象，那么x.hashCode()与y.hashCode()基本是不会相同的。 Java规范：如果两个对象通过调用equals方法是相等的，那么这两个对象调用hashCode方法必须返回相同的整数。 如果equals不相等，hashcode不一定需要不相同（可以相同，但是不建议） 1、如果两个对象equals，Java运行时环境会认为他们的hashcode一定相等。 2、如果两个对象不equals，他们的hashcode有可能相等。 3、如果两个对象hashcode相等，他们不一定equals。 4、如果两个对象hashcode不相等，他们一定不equals。 对于Map接口的实现类（比如hashmap)来说： 他的hashCode()方法是继承自Object类的，对象调用hashCode()获得的是对象的内存地址，即使这两个对象的值是相同的，返回的hashCode()也是不相同的，即会出现equals()返回true，hashCode()返回false。 所以为了判断两个hashmap中相同key对应的值是否相等，重写了equals的判断，也应该重载hashCode()方法。 ①先求key的hashCode()，比较他们的值是否相等 ②hashCode()相等，再比较equals()是否相等。（equals()比较的是对象是否相同) 如果不重写hashCode()方法，hashmap在插入新元素的时候，如果新元素的key跟map里的一个key是一样的，两个key通过equals()方法比较返回true，hashCode()不重写的话他们得到的hashCode()却是不一样的，就会插入到不同的位置，从而hashmap会出现重复的key。 重写hashCode()的原则 ​ （1）同一个对象多次调用hashCode()方法应该返回相同的值； ​ （2）当两个对象通过equals()方法比较返回true时，这两个对象的hashCode()应该返回相等的（int）值； ​ （3）对象中用作equals()方法比较标准的Filed(成员变量（类属性）)，都应该用来计算hashCode值。","categories":[{"name":"computer science计算机技术","slug":"computer-science计算机技术","permalink":"https://linh47.github.io/categories/computer-science计算机技术/"},{"name":"Java","slug":"computer-science计算机技术/Java","permalink":"https://linh47.github.io/categories/computer-science计算机技术/Java/"}],"tags":[{"name":"-Java SE - 面试题","slug":"Java-SE-面试题","permalink":"https://linh47.github.io/tags/Java-SE-面试题/"}]},{"title":"Java并发编程（多线程）","slug":"Java并发编程（多线程）","date":"2019-03-18T04:32:09.107Z","updated":"2019-03-20T14:53:50.297Z","comments":true,"path":"2019/03/18/Java并发编程（多线程）/","link":"","permalink":"https://linh47.github.io/2019/03/18/Java并发编程（多线程）/","excerpt":"此文为自己总结的Java多线程相关的知识点，参考了多篇文章和《疯狂java讲义第四版》，加入了自己对概念的理解和疑问解答。","text":"此文为自己总结的Java多线程相关的知识点，参考了多篇文章和《疯狂java讲义第四版》，加入了自己对概念的理解和疑问解答。 Java并发编程（多线程）运行中的程序就是进程，进程内部可以包含多个线程（顺序执行流） 具体例子：打开QQ、浏览器，等于开了2个进程，然后QQ里的任务可以交给多个线程执行，浏览器也是。 一、并发与并行并发：​ 同一时刻只有一条指令执行 并行：​ 同一时刻有多条指令在不同的处理器上同时执行 我的疑问：单处理器不能实现并行吗？并发能不能多个任务一起执行？ 解答：只有一个以上的CPU才能实现并行，每个CPU可以处理一个进程，互不抢占资源，可以同时进行。单个CPU只能实现并发，并发看上去好像多个任务在同时进行，实际上在底层，每个任务只能执行一小段时间就会被切换，所以具体到一个时刻，只有一条指令能执行。 举个例子： ​ 一台咖啡机-两个队伍的人轮流拿咖啡，一个时刻只能拿一杯咖啡。 ​ 两台咖啡机-两个队伍的人-可以同时拿到2杯咖啡。 并发——多个事情在一个时间段内同时发生了。要抢占资源 并行——多个事情在同一个时间点同时发生了。不抢占资源。【只在多CPU情况下发生】 我的疑问：多核CPU和多个CPU怎么理解？CPU的线程数又是什么？多线程程序的线程是在一个CPU上跑还是分散到所有CPU上跑？ 解答： CPU个数 CPU核数 逻辑CPU数 物理上一整块CPU的个数 一个CPU里面的物理核心组件 物理核心对应的逻辑CPU数量 CPU的个数就是纯物理的组件个数。CPU的核数也是物理上的，是一个CPU里面的核心组件的个数。 一个核-一个进程-多个线程（并发）。多核之间是并行执行不同的线程的。 Intel发明了超线程技术，一个核心可以支持多个逻辑CPU，逻辑CPU数&gt;=核数，逻辑CPU之间是并行执行的，单个核之内是并发的。自己机器可以通过命令行cmd-wmic-cpu get 得到（win10可以直接看任务管理器），我的是 NumberOfCores NumberOfEnabledCore NumberOfLogicalProcessors 4 4 8 我的CPU物理上有4个核，然后可以有 8个逻辑CPU，就是最多并行8个线程。 所以存在单核多个CPU的组合，也有单个CPU多核（更常见）。 怎么选择算法呢？运行的线程数和CPU核数一样的时候效率最高，除非这个线程要做的计算太少，等待的IO操作太多。增加线程能减少的等待时间要抵过线程切换的开销才好。 IO操作密集的任务可以考虑使用多线程。 计算密集的单核CPU就不要搞多线程了，让CPU专心计算比较好。除非是重视人机交互，不想程序卡死在那里才考虑使用多线程。计算密集的多核CPU使用多线程，可以让其他核心满载。 二、线程与进程进程的概念和特征 进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。 进程是处于运行过程中的程序，是系统进行资源分配和调度的一个独立单位。 独立性： ​ 独立存在，独立资源，私有的地址空间。 动态性： ​ 正在系统中活动的指令集合，与时间有关，有生命周期和状态。 并发性： ​ 多个进程可以在单个CPU上并发执行，进程之间不会相互影响。 ​ 并发时，CPU不断地轮换执行进程，多个进程指令被快速地轮换执行，宏观上达到多个进程同时执行的效果。 进程与程序的区别进程是正在执行的程序，是正在系统中活动的指令集合。进程是动态的，有自己的生命周期和不同的状态。程序只是静态的指令集合。 线程的概念 线程，有时被称为轻量级进程(Lightweight Process，LWP），是程序执行流的最小单元。线程是程序中一个单一的顺序控制流程。进程内一个相对独立的、可调度的执行单元，是系统独立调度和分派CPU的基本单位指运行中的程序的调度单位。在单个程序中同时运行多个线程完成不同的工作，称为多线程。 一个进程至少有一个主线程，可以有多个线程。进程负责调度和管理线程。 线程是进程的组成部分/执行单元。线程是独立的、并发的执行流。 线程可以拥有自己的堆栈、程序计数器、局部变量，但是不拥有系统资源。 线程不拥有系统资源，它们共享父进程拥有的全部资源。比如内存、文件句柄和其他进程的状态。 每个线程都有自己的父进程。一个线程可以创建和撤销另一个线程。 线程运行的时候不知道其他线程是否存在。线程的执行是抢占式的。 使用多线程的好处 ​ 创建线程的代价比创建进程小得多，创建进程要分配内存和资源 ​ 同一进程的线程之间可以共享资源，线程间的通信开销也更小，实现多任务的并发效率更高 ​ 减少了等待IO操作处理的时间，资源利用率更高 ​ Java语言内置了多线程功能的支持，简化了多线程编程 使用多线程的代价 ​ 程序更加复杂，需要更加注意线程之间的交互，不正确的线程同步会产生错误 ​ CPU在做上下文切换时也有开销 挂起一个进程 恢复一个进程 跳转到程序计数器所指向的位置 ​ 管理线程也要消耗资源（可以通过线程池缓解） 三、线程的创建 继承Thread类 实现Runnable接口 实现Callable接口（可以有返回值、抛出异常） 注：实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以说任务是通过线程驱动从而执行的。 我的理解：所有的线程对象都必须是Thread类/其子类 的实例 创建线程的方式对比 实现接口的优缺点 Java 不支持多重继承，但是可以实现多个接口；线程类只是实现了接口的话，还可以继承其他类。 多个线程可以共享一个target对象，适合多个相同线程处理同一份资源的情况 编写程序会比较复杂，访问当前线程只能用Thread.currentThread()方法 继承Thread类的优缺点 不能再继承其他父类 编写简单，直接使用this可以获得当前线程 1、继承Thread类，创建线程类12345678910111213141516public class FirstThread extends Thread&#123; private int i;//这个变量不可以被多个线程共享 public void run() &#123; //线程执行体，也就是线程要执行的任务 //想获取当前线程，可以直接用this &#125;&#125;public static void main(String[] args)&#123; new FirstThread().start(); //start是启动线程，然后会调用线程的run方法。 new FirstThread().start(); //这样会启动另一个线程&#125; 注意：程序运行时会创建一个主线程，主线程的线程执行体就是main方法，然后再创建显式定义的其他线程。 ​ 使用继承Thread类来创建线程时，多个线程之间无法共享线程类的实例变量。 ​ 我的理解：因为每个线程都是继承Thread线程类（比如这个例子就是FirstThread）的一个线程对象启动的（new FirstThread()），一个线程对应了一个对象，所以他们的实例变量不是同一个对象的，就没法共享。 2、实现Runnable接口，创建线程类 123456789101112131415161718192021public class SecondThread implements Runnable&#123; private int i;//这个变量可以被2个线程共享 public void run() &#123; //线程执行体，也就是线程要执行的任务 //想获取当前线程，只能调用Thread.currentThread()方法 &#125;&#125;public static void main(String[] args)&#123; //注意与继承Thread类的对象创建进行区分 //先创建线程类的对象 SecondThread st=new SecondThread(); //再以线程类的对象作为Thread类的target，创建真正的线程对象 //也就是说，线程对象一定得是Thread类/其子类 的实例 //我们实现接口的类不能作为线程对象去启动线程 new Thread(st,\"线程1\").start(); //start是启动线程，然后会调用线程的run方法。 new Thread(st,\"线程2\").start();&#125; 注意：这个时候，因为2个线程实际上都是用同一个线程类（SecondThread）做target来创建线程对象的，所以线程1和线程2是共享线程类（SecondThread）的实例变量的。 ​ 我的理解：多个线程可以共享同一个target，也就是可以共享target对应类的实例变量。 Java 8开始，Runnable接口是函数式接口，可以用Lambda表达式创建Runnable对象。 3、使用Callable和Future创建线程Callable接口可以看做Runnable接口的增强版，它提供的call()方法也可以作为线程执行体，但是功能更强大。它是Java 5新增的接口，也是函数式接口。 call()方法： ​ 有返回值 ​ 可以声明抛出异常 但是，Callable接口不是Runnable接口的子接口，它不可以直接作为Thread的target。 Future接口也是Java 5新增的，它代表Callable接口的call()方法的返回值。 FutureTask是Future接口的实现类，它还实现了Runnable接口。 所以——FutureTask 可以作为Thread类的target，又能获取到callI()方法的返回值。 FutureTask 常用方法 cancel(boolean xxx) get() 阻塞直到子线程结束得到返回值 get(long timeout,TimeUnit unit) 限时阻塞，超时抛出TimeoutException异常 isCancelled() isDone() 创建、启动、使用有返回值的线程的步骤如下： 12345678910111213141516171819202122232425262728public class ThirdThread &#123; public static void main(String[] args) &#123; //先创建Callable对象 ThirdThread rt=new ThirdThread(); //使用Lambda创建Callable&lt;Integer&gt;对象 //使用FutureTask包装Callable对象 //参数的泛型类型必须和返回值类型对应，包装类 FutureTask&lt;Integer&gt; task=new FutureTask&lt;Integer&gt; ( (Callable&lt;Integer&gt;)()-&gt; &#123; int i=0; //线程执行体 return i; &#125;); //以包装后的Callable对象作为Thread的target创建、启动线程 new Thread(task,\"线程3\").start(); //可以用FutureTask类的get方法获取线程执行体的返回值，get方法可以抛出超时异常。 try &#123; System.out.println(\"子线程的返回值\"+task.get()); &#125;catch(Exception ex) &#123; ex.printStackTrace(); &#125; &#125;&#125; 四、线程的生命周期因为一个线程不可能一直霸占CPU运行，所以CPU会切换线程，就会有线程的不同状态的转换。 线程的状态（5种） 新建 new new完，虚拟机分配内存，初始化成员变量的值 就绪（可运行） runnable 调用了start()方法，虚拟机创建方法调用栈和程序计数器。表示线程可以运行了。 但是未必马上就开始执行线程，而是要等待CPU。 要立刻执行的话，可以让当前运行的线程sleep一毫秒，让CPU执行这个就绪的线程。 只能对new状态的线程调用start()方法，否则引发IllegalThreadStateException异常。（对同一个线程调用2次start()同理） 运行 running 线程获得了CPU，开始执行run()方法。 单CPU，一个时刻只有一个线程处于运行状态。 多CPU，多个线程并行执行。如果线程数比CPU数多，依然会存在线程在一个CPU上轮换的现象。 线程不可能一直处于运行状态，除非它瞬间就执行结束了。线程需要被中断，让给其他线程执行。 根据系统策略不同，调度细节也不同。 ​ ①抢占式策略的系统（桌面/服务器端系统），每个线程被分配固定的时间段，用完了资源就被剥夺，其他线程被执行。 ​ ②协作式调度策略的系统（手机系统），每个线程主动放弃所占用的资源，调用sleep()或者yield()方法。 阻塞 blocked 发生如下情况，线程会进入阻塞状态： ​ ①调用sleep()方法 ​ ②调用阻塞式IO方法，在方法返回前都处于阻塞状态 ​ ③线程试图获得一个同步监视器，但该监视器被其他线程所持有。 ​ ④线程在等待某个通知notify ​ ⑤程序调用了suspend()方法将线程挂起（容易导致死锁，避免使用） 阻塞的线程被解除后可以进入就绪状态，必须等待再次调度才能运行。 解除阻塞状态： ​ ①调用sleep()的线程经过了指定时间 ​ ②阻塞式IO方法已经返回 ​ ③线程已经获得了同步监视器 ​ ④线程在等待通知时，其他线程发出了通知 ​ ⑤处于挂起状态的线程被调用了resume()方法恢复 死亡 dead 线程结束后就处于死亡状态 结束的方式： ​ ①run()或者call()方法执行完成 ​ ②线程抛出一个未捕获的exception或error ​ ③直接调用线程的stop()方法（容易导致死锁，不建议使用） 注意，子线程不受主线程结束的影响，不会随着它结束。 死亡的线程就不要再调用start()启动它了。否则会引发IllegalThreadStateException异常。 调用isAlive()方法，可以测试线程是否死亡 就绪、运行、阻塞时返回true，新建、死亡时返回false。 我的理解：线程不能进入运行的状态就算它不是活着的，新建的时候它还不能直接变成运行。 测试isAlive()代码 12345678910111213141516171819202122232425262728public class TwoThreadAlive extends Thread&#123; public void run() &#123; for (int i = 0; i &lt; 5; i++) &#123; printMsg(); System.out.println(\"for in run\"); &#125; System.out.println(\"The end of run(), tt.isAlive()=\" + Thread.currentThread().isAlive()); &#125; public void printMsg() &#123; Thread t = Thread.currentThread();//获取当前的线程对象 String name = t.getName(); System.out.println(\"name=\" + name); &#125; public static void main(String[] args) &#123; TwoThreadAlive tt=new TwoThreadAlive(); tt.setName(\"ThreadObject\"); System.out.println(\"after new,before start(), tt.isAlive()=\" + tt.isAlive()); System.out.println(\"start()\"); tt.start(); System.out.println(\"just after start(), tt.isAlive()=\" + tt.isAlive()); for (int i = 0; i &lt; 5; i++) &#123; System.out.println(\"for in main，current Thread is:\"+Thread.currentThread().getName()); &#125; tt.printMsg();//注意这一行，实际上是main线程执行了printMsg()方法 System.out.println(\"The end of main(), tt.isAlive()=\" + tt.isAlive()); &#125;&#125; 输出结果（每次顺序会有小小区别） 123456789101112131415161718192021after new,before start(), tt.isAlive()=falsestart()just after start(), tt.isAlive()=truefor in main，current Thread is:mainfor in main，current Thread is:mainfor in main，current Thread is:mainfor in main，current Thread is:mainfor in main，current Thread is:mainname=mainname=ThreadObjectfor in runThe end of main(), tt.isAlive()=truename=ThreadObjectfor in runname=ThreadObjectfor in runname=ThreadObjectfor in runname=ThreadObjectfor in runThe end of run(), tt.isAlive()=true 从结果可以明显地看出两点： 1、刚new的线程isAlive是false 2、main方法结束，子线程要执行完再结束 我的理解：在main方法中再调用子线程对象的实例方法，实际上还是main线程去执行方法。 tt.printMsg();//注意这一行，实际上是main线程执行了printMsg()方法 输出的是name=main。 从整个输出语句看，主线程的for循环和子线程的run方法是轮换执行的。可以看到main线程还要执行一次tt对象的printMsg()方法。 我的疑惑：主线程什么时候死亡？是main方法运行完就死亡吗？还是主线程要在后台做完其他工作再死亡？ 我的解答： ​ 需要区分守护线程和非守护线程。 ​ 守护线程是JVM自己要用的线程，用来实现GC、监视等。其他的都算非守护进程，包括主线程。 ​ 程序运行的时候会先创建守护线程。然后创建主线程，主线程找main方法，调用main方法。 ​ 默认情况下，main方法里面创建的都是非守护进程。对于CPU来说，主线程也是个线程。所以主线程的结束不影响其他线程。所以主线程是有可能先结束，进入死亡状态的。 ​ JVM等所有非守护进程执行结束，然后退出。当 JVM 退出时，所有仍然存在的守护线程都将被抛弃，既不会执行 finally 部分的代码，也不会执行 stack unwound 操作，JVM 会直接退出。 ​ 可以设置一个线程为守护线程，Thread.setDaemon(true); ，也就是它执不执行完JVM都会照常关闭，JVM不再等它。 新的线程是否初始为守护线程，取决于启动该线程的线程是否为守护线程。 守护线程默认启动的线程为守护线程，非守护线程启动的线程默认为非守护线程。 主线程（非守护线程）启用一个守护线程，需要调用Thread.setDaemon来设置启动线程为守护线程。 五、控制线程的执行","categories":[{"name":"computer science计算机技术","slug":"computer-science计算机技术","permalink":"https://linh47.github.io/categories/computer-science计算机技术/"},{"name":"Java","slug":"computer-science计算机技术/Java","permalink":"https://linh47.github.io/categories/computer-science计算机技术/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://linh47.github.io/tags/Java/"},{"name":"Thread","slug":"Thread","permalink":"https://linh47.github.io/tags/Thread/"},{"name":"多线程","slug":"多线程","permalink":"https://linh47.github.io/tags/多线程/"},{"name":"进程","slug":"进程","permalink":"https://linh47.github.io/tags/进程/"},{"name":"并发","slug":"并发","permalink":"https://linh47.github.io/tags/并发/"}]},{"title":"论文笔记-LPAwb+和DIRTLPAwb+","slug":"论文笔记-LPAwb+和DIRTLPAwb+","date":"2019-03-17T13:43:56.454Z","updated":"2019-03-18T14:07:23.129Z","comments":true,"path":"2019/03/17/论文笔记-LPAwb+和DIRTLPAwb+/","link":"","permalink":"https://linh47.github.io/2019/03/17/论文笔记-LPAwb+和DIRTLPAwb+/","excerpt":"本篇为论文Improved community detection in weighted bipartite networks的阅读笔记。该论文为复杂网络领域的社区发现算法，于2016年发表于 Royal Society open science（impact factor 2.5)。","text":"本篇为论文Improved community detection in weighted bipartite networks的阅读笔记。该论文为复杂网络领域的社区发现算法，于2016年发表于 Royal Society open science（impact factor 2.5)。Beckett S J. Improved community detection in weighted bipartite networks[J]. Royal Society open science, 2016, 3(1): 140536. 概述：​ 这篇论文于2016年发表于 Royal Society open science（impact factor 2.5)。 ​ 论文改进了LPAb+算法（LPAb+改进自LPA标签传播算法），用于二分加权网络上的社区划分。作者Beckett 提出了LPAwb+和DIRTLPAwb+两种算法。其中DIRTLPAwb+是对LPAwb+的使用改进算法。 ​ 所用数据集： 生成网络（800个）【QuanBiMo、LPAwb+、DIRTLPAwb+在每个网络上跑一次，取最好结果】 ​ 生成参数： ​ 行节点数30 列节点数50 ​ 社区数 2或10 ​ 社区边权重随机，服从偏态负二项分布 （skewed negative binomial distribution） ​ 分散参数 (0.5,2.5)，平均值为4 ​ 噪声noise=0,0.01,0.25,0.5 23种plant-pollinator网络【LPAwb+、DIRTLPAwb+在每个网络上跑100次，取最好结果】 ​ 下载地址： ​ https://www.nceas.ucsb.edu/interactionweb/resources.html#plant_pollinator ​ 论文LPAwb+源代码： ​ https://github.com/sjbeckett/weighted-modularity-LPAwbPLUS ​ 对比算法： ​ QuanBiMo ​ 评价指标： ​ 检测出的社区数占已知社区数的比率 ​ 改进的模块度 ​ NMI 亮点：​ 模块度改进了Barber’s Modularity，使其适用于加权二分网络。 ​ LPAwb+速度快，适用于大型网络。 ​ DIRTLPAwb+虽然也依赖输入参数，但是它的参数比QuanBiMo更有意义，表现更稳定，而且结果不比LPAwb+差。 一句话总结： ​ LPAwb+容易陷入次最优化的情况，它也依赖于初始化的标签，但他的速度占优势。 ​ DIRTLPAwb+从miu个标签中随机选择作为初始化标签，计算了多次LPAwb+，返回最好的结果。速度肯定比单次LPAwb+慢，但是表现接近LPAwb+，优于QuanBiMo。 ​ LPAwb+和DIRTLPAwb+都受网络的社区数的影响，也受社区之间节点连接程度的影响。 详解QuanBiMo ​ 第一个考虑权重的适用于二分网络的基于最大化模块度的社区发现算法 ​ 在多层随机网络上使用模拟退火算法 LPAb+ ​ 标签传播算法+多步合并。时间复杂度小，社区发现结果较好，但是没考虑权重。 模块度 Barber’s Modularity 二分网络的两种不同类型的节点可以分在同一个社区。 ​ 注：Guimera’s模块度就是不同类的节点不会划分到一个社区中。 ​ 公式： 改进的适用于加权网络的Barber’s Modularity 用来跟其他算法做比较而标准化的模块度 二分网络和加权网络都能用的模块度","categories":[{"name":"搞学术","slug":"搞学术","permalink":"https://linh47.github.io/categories/搞学术/"},{"name":"复杂网络-社区发现","slug":"搞学术/复杂网络-社区发现","permalink":"https://linh47.github.io/categories/搞学术/复杂网络-社区发现/"}],"tags":[{"name":"复杂网络","slug":"复杂网络","permalink":"https://linh47.github.io/tags/复杂网络/"},{"name":"社区发现","slug":"社区发现","permalink":"https://linh47.github.io/tags/社区发现/"},{"name":"二分网络","slug":"二分网络","permalink":"https://linh47.github.io/tags/二分网络/"},{"name":"complex networks","slug":"complex-networks","permalink":"https://linh47.github.io/tags/complex-networks/"},{"name":"bipartite networks","slug":"bipartite-networks","permalink":"https://linh47.github.io/tags/bipartite-networks/"},{"name":"community detection","slug":"community-detection","permalink":"https://linh47.github.io/tags/community-detection/"},{"name":"LPA","slug":"LPA","permalink":"https://linh47.github.io/tags/LPA/"}]},{"title":"给博客加上背景音乐吧","slug":"给博客加上背景音乐吧","date":"2019-03-13T17:05:23.000Z","updated":"2019-03-18T09:35:19.881Z","comments":true,"path":"2019/03/14/给博客加上背景音乐吧/","link":"","permalink":"https://linh47.github.io/2019/03/14/给博客加上背景音乐吧/","excerpt":"介绍在博客中加入网易云音乐播放器的方法。","text":"介绍在博客中加入网易云音乐播放器的方法。 我是一个很爱听随机歌的人，没有歌总觉得少了什么。 于是给博客加上了播放器~~~ 查了一下，侧边栏是通过网易云的外链播放器iframe实现的，文章内则靠hexo的两个插件实现。 1、侧边栏播放器增加BGM栏，步骤跟其他的widget差不多 hueman的配置文件12widgets:- mymusic zh-CN加上翻译1mymusic: &apos;背景音乐&apos; layout的widget里面加ejs文件12345678&lt;% if (site.tags.length) &#123; %&gt; &lt;div class=&quot;widget-wrap widget-list&quot;&gt; &lt;h3 class=&quot;widget-title&quot;&gt;&lt;%= __(&apos;BGM&apos;) %&gt;&lt;/h3&gt; &lt;div class=&quot;widget&quot;&gt; &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=300 height=450 src=&quot;//music.163.com/outchain/player?type=0&amp;id=884698131&amp;auto=1&amp;height=430&quot;&gt;&lt;/iframe&gt; &lt;/div&gt; &lt;/div&gt;&lt;% &#125; %&gt; 重点就是ejs文件里的啦，这个生成非常简单。 打开网易云音乐的网页版，找到喜欢的单曲或者歌单，只要不收钱的不要版权的都可以导出外链播放器。 选择iframe形式的，自己选个大小，稍微调一下就可以复制到自己的ejs文件里啦。 我的大小是300宽，450高。auto=1是自动播放，0就是手动播放。 有的能生成播放器的也未必播放得了，在网易云插件就可以试出来。 2、文章内播放器使用hexo的插件hexo-tag-aplayer ​ 安装 1npm install --save hexo-tag-aplayer ​ 可以把音乐放到之前提到过的文章的资源文件夹里，有相对路径可以引用 1&#123;% aplayer &quot;如常&quot; &quot;房东的猫&quot; &quot;房东的猫-如常.flac&quot; &quot;ruchang.jpg&quot; &quot;lrc:房东的猫-如常.lrc&quot; %&#125; [00:00.00] 作曲 : 少年佩 [00:01.00] 作词 : 一只然 [00:11.10]制作人/编曲/弦乐编写 : 樊哲忠 [00:13.24]监制 : 李纤橙 [00:14.74]主唱/和声 : 红鼻子小黑 [00:16.44]弦乐 : 国际首席爱乐团 [00:17.93]打击乐 : 陳柏州 [00:19.03]录音师 : 汝文博 [00:20.23]录音室 : BIG J Studio Beijing [00:21.53]混音師 : 赵靖 [00:31.90]很多时候你一个人习惯了 [00:35.94]就无法给与嘱托 [00:40.53]你习惯了如风般不结伴穿梭 [00:46.37]影子都没留片刻 [00:52.53]很多时候你一个人常常是 [00:56.12]只考虑一个人的 [01:00.91]你独舞喜怒哀乐任光阴如何 [01:06.35]任光阴如何收割 [01:13.23]你就是如此令人神往的角色 [01:17.97]在造物主的手中不拘一格 [01:23.41]锋利中带着柔和 [01:27.90]柔和里伴随冷落 [01:33.49]你就有如此不可多得的神色 [01:37.83]你每种表情无需费力把我俘获 [01:44.56]平静里带着谴责 [01:47.90]谴责却没有愠火 [02:10.45]很多时候你一个人厌倦了 [02:14.39]序列有秩的生活 [02:19.13]你厌倦同一班车被夕阳吞没 [02:24.72]却怨的不动声色 [02:34.15]很多时候你一个人就这么 [02:38.69]跳入了一扇沉默 [02:44.08]看起来属于陌生或属于暮色 [02:49.66]却不是属于谁的 [02:57.45]你就是如此令人神往的角色 [03:01.14]在造物主的手中不拘一格 [03:07.02]锋利中带着柔和 [03:11.46]柔和里伴随冷落 [03:17.25]你就有如此不可多得的神色 [03:21.39]你每种表情无需费力把我俘获 [03:28.08]平静里带着谴责 [03:31.17]谴责却没有愠火 [04:17.40]你就是如此令人神往的角色 [04:22.44]在造物主的手中不拘一格 [04:27.88]锋利中带着柔和 [04:32.32]柔和里伴随冷落 [04:37.80]你就有如此不可多得的神色 [04:42.39]你每种表情无需费力把我俘获 [04:48.73]平静里带着谴责 [04:52.07]谴责却没有愠火 [04:58.26]你告别该有的脆弱 [05:03.15]你放生无罪的困惑 [05:08.19]你沿着真心一路上 [05:11.78]化作未染的清澈 var ap = new APlayer({ element: document.getElementById(\"aplayer-UhKyfGBy\"), narrow: false, autoplay: false, showlrc: 2, music: { title: \"如常\", author: \"房东的猫\", url: \"房东的猫-如常.flac\", pic: \"/2019/03/14/给博客加上背景音乐吧/ruchang.jpg\", lrc: \"房东的猫-如常.lrc\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 《如常》我是买了的啦~~~强烈安利房东的猫，虽然现在已经不算小众了哈哈哈。听现场唱歌好舒服啊啊啊~两个妹子都是干干净净非常美好。","categories":[{"name":"computer science计算机技术","slug":"computer-science计算机技术","permalink":"https://linh47.github.io/categories/computer-science计算机技术/"},{"name":"blog set up博客搭建","slug":"computer-science计算机技术/blog-set-up博客搭建","permalink":"https://linh47.github.io/categories/computer-science计算机技术/blog-set-up博客搭建/"}],"tags":[{"name":"BGM","slug":"BGM","permalink":"https://linh47.github.io/tags/BGM/"},{"name":"网易云音乐","slug":"网易云音乐","permalink":"https://linh47.github.io/tags/网易云音乐/"}]},{"title":"hexo使用本地图片","slug":"hexo使用本地图片","date":"2019-03-13T14:25:30.000Z","updated":"2019-03-18T09:34:30.961Z","comments":true,"path":"2019/03/13/hexo使用本地图片/","link":"","permalink":"https://linh47.github.io/2019/03/13/hexo使用本地图片/","excerpt":"介绍在MD文档中插入本地图片的方法。","text":"介绍在MD文档中插入本地图片的方法。 1、hexo的配置文件post_asset_folder:true 意思是每新建一个文档，就生成一个文件夹用来放对应的资源 2、下载插件在hexo的目录下执行npm install https://github.com/CodeFalling/hexo-asset-image --save 3、图片放在文档的文件夹下4、在MD文档中引用本地图片其实使用的是hexo的标签 1&#123;% asset_img wallhaven-681094.png 壁纸示例%&#125;","categories":[{"name":"computer science计算机技术","slug":"computer-science计算机技术","permalink":"https://linh47.github.io/categories/computer-science计算机技术/"},{"name":"blog set up博客搭建","slug":"computer-science计算机技术/blog-set-up博客搭建","permalink":"https://linh47.github.io/categories/computer-science计算机技术/blog-set-up博客搭建/"}],"tags":[]},{"title":"教你一天搭建一个免费的个人博客","slug":"教你一天搭建一个免费的个人博客","date":"2019-03-13T09:40:11.871Z","updated":"2019-03-18T09:33:40.709Z","comments":true,"path":"2019/03/13/教你一天搭建一个免费的个人博客/","link":"","permalink":"https://linh47.github.io/2019/03/13/教你一天搭建一个免费的个人博客/","excerpt":"介绍使用github pages和hexo搭建个人博客的方法。","text":"介绍使用github pages和hexo搭建个人博客的方法。 前言​ 不知道你们有没有跟我一样的感觉，我想总结学到的东西和经验，通过写作练习正确表达自己的想法，教别人的同时也会逼着自己去学懂一件事情；也不是作为自媒体想运营获得收入或者出名，只是想记录一些比较私人化的东西。 怀着一腔鸡血，结果我发现没有合适的平台可以自由地写作。 社恐患者其实也很怕没有意义的互动，对点赞转发评论的回复是很耗费精力的。 创建自己的公众号太麻烦，填许多资料还要每年交300块保护费，公众号内容还需要被审核，一些想法被平时熟悉的人知道也有点不好意思。 普通的博客平台比如CSDN、新浪等，社交性太强，有大量广告和自由度有限的博客模板。 昨天搜到了github Pages，发现经过不是非常复杂的操作，就能拥有一个免费、无限流量、还能部分自定义网址（前缀）又不需要购买域名和域名备案的个人博客。实际上Github Pages能实现的不仅仅是博客，简直就可以作为你的个人网站来使用。你可以控制它看起来是什么样子，有许多好看的主题可以挑选，功能块自己能够定义，也可以充满安全感地写作。 你所需要的不过是跟着教程一步步做下来，就能得到你的个人博客啦。 如果你感兴趣的话，就继续看吧。 需要一点点计算机操作的基础，比如cmd命令行怎么用，如何科学地打开你想要的网站，如何在官方渠道下载安全的安装软件，如何使用git和github。这些都很容易搜到的。 所需工具 GitHub Pages Nodejs npm Hexo Typora 主要步骤 https://pages.github.com/ 跟着官方流程把github Pages搭好。 https://hexo.io/zh-cn/ 跟着官方教程下载所需的组件，安装hexo。 使用hexo进行对应页面的创建。 安装好hexo对应的git插件。 使用hexo部署到你的github pages。 使用Typora进行MD文档的编辑。 Hexo部分hexo的配置文件yaml格式非常严格，空格不能少，也必须是英文。编码必须是UTF-8，不能带BOM。 修改yaml部分用notepad++。 记录一下部署的配置格式，每个冒号后面必须跟一个空格。 1234deploy: type: git repository: https://github.com/linh47/linh47.github.io.git branch: master Hexo常用命令： 含义 命令 简写 新建文档或页面 hexo new [page] “标题” hexo n xxx 清除已经生产的静态页面（public文件夹） hexo clean hexo c 重新生成静态页面 hexo generate hexo g 启动本地服务器 hexo server hexo s 部署到远程服务器(github) hexo deploy hexo d 主题部分hexo提供了多样化的主题可供选择。https://hexo.io/themes/ 我喜欢的是hueman主题。以下是设置主题的参考。 Hueman主题官方文档：https://github.com/ppoffice/hexo-theme-hueman/wiki 可参考文档：https://arvinsir.com/2017/05/19/hexo-themes-hueman/ 使用步骤 clone到hexo的theme文件夹下。 https://github.com/ppoffice/hexo-theme-hueman.git hexo的配置文件中theme 改成hueman。 修改hueman的配置文件，刚clone的后缀.example要删掉。 配置主题 ​ 修改语言：hexo的配置文件中 language改成zh-CN ​ 修改页面头、脚：hueman/source/css/_partial/header.styl和footer.styl文件 。 ​ 图片路径：hueman/source/css/images ​ logo大小：hueman的配置文件中 12345customize: logo: width: 165 height: 60 url: images/logo-header.png ​ 显示网站访问量： ​ 在hueman/layout/common/footer.ejs添加两句。注意编码！utf-8。 1&lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 12&lt;span id=&quot;busuanzi_container_site_pv&quot;&gt;本站总访问量为：&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt; 配置网站的语言 ​ hueman的配置文件中全部写英文，在language文件夹下的zh-CN.yml增加对应的中文翻译。 ​ 123456789index: home: &apos;主页&apos; about: &apos;关于&apos; search: &apos;搜索&apos; archive: &apos;归档&apos; category: &apos;分类&apos; uncategorized: &apos;未分类&apos; tag: &apos;标签&apos; lifestyle: &apos;生活方式&apos; 网站的菜单与目录： hexo的配置文件中有category_dir: categories。hexo下面的source有categories文件夹就可以。 **hueman的配置里，菜单项就不用一个个写了！！！hueman的菜单栏应该不包括文章的具体分类项。 文章直接在开头写categories和tags就可以了！ 文章的分类（hueman最多支持2级）和标签 在MD文件的最前面加 12345678---title: 博客是怎么从0到1的date: 2019-03-12 21:58:36tags: blogcategories: - ittech - blog--- 补充： 在站点目录 /scaffolds/post.md 文件中添加一项categories，这样每次新建博客文章 new 出来的 .md 文件就都带 categories 了 如果generate报错，用notepad++打开MD检查开头的格式。 在typora软件里面，— 和 — 会自动省略，显示成灰色的就可以了，不用再手动加上去。","categories":[{"name":"computer science计算机技术","slug":"computer-science计算机技术","permalink":"https://linh47.github.io/categories/computer-science计算机技术/"},{"name":"blog set up博客搭建","slug":"computer-science计算机技术/blog-set-up博客搭建","permalink":"https://linh47.github.io/categories/computer-science计算机技术/blog-set-up博客搭建/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://linh47.github.io/tags/blog/"},{"name":"hexo","slug":"hexo","permalink":"https://linh47.github.io/tags/hexo/"},{"name":"hueman","slug":"hueman","permalink":"https://linh47.github.io/tags/hueman/"},{"name":"github pages","slug":"github-pages","permalink":"https://linh47.github.io/tags/github-pages/"}]},{"title":"让谷歌检索到你的个人博客","slug":"让谷歌检索到你的个人博客","date":"2019-03-13T09:16:16.000Z","updated":"2019-03-18T09:34:10.945Z","comments":true,"path":"2019/03/13/让谷歌检索到你的个人博客/","link":"","permalink":"https://linh47.github.io/2019/03/13/让谷歌检索到你的个人博客/","excerpt":"介绍能够让搜索引擎收录你的个人博客并提供检索内容的方法。","text":"介绍能够让搜索引擎收录你的个人博客并提供检索内容的方法。刚搭建完博客能够访问的时候，我以为随便百度谷歌都能搜到我写的东西了，屁颠屁颠搜了下，一点相关的都没有，然后看了教程才知道，想让自己的网站被检索，还需要上谷歌填写资料。 检查是否被收录的方法： 方法：打开百度或谷歌搜索，在搜索框里输入 1site:你的博客地址 如果显示 尝试使用 Google Search Consolewww.google.com/webmasters/ 您对 linh47.github.io 是否具有所有权？请从 Google 获取索引和排名数据。 就是还不能被搜索引擎检索到呢。 那么记录一下怎样让谷歌检索到自己个人博客的方法吧！ 1、生成自己网站的站点地图这个站点地图很多地方都要用到，值得一做。 先安装自动生成插件 12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 在hexo的配置文件中添加 12345# 自动生成sitemapsitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml 配置好了以后执行一下 hexo g，就能在博客文件\\public目录下找到中生成的sitemap.xml和baidusitemap.xml了。 2、提交网站信息，设置html的meta标记你想让谷歌检索你的博客，首先要证明这个网站你有所有权，也就是你可以更改网站的内容。 有几种验证方法，由于hexo经常会把生成的静态文件clean掉，所以我们用在主题的头文件中添加html的meta标记的方法，一劳永逸。 https://www.google.com/webmasters/ https://ziyuan.baidu.com/site 先跟着网址指引一步步填写信息。 然后复制网址提供给你验证的meta html的meta放在hueman里面的head.ejs文件里面哦。 填好以后要先重新部署才能进行验证。 3、验证所有权后就可以提交站点地图站点地图的意义在于搜索引擎能够更好地抓取网站的内容。 根据对应搜索引擎的提示，谷歌提交sitemap.xml，百度提交baidusitemap.xml就可以了。 4、检索生效期都设置好了以后并不能马上就搜到自己的博客内容，因为要等搜索引擎更新他的索引。","categories":[{"name":"computer science计算机技术","slug":"computer-science计算机技术","permalink":"https://linh47.github.io/categories/computer-science计算机技术/"},{"name":"blog set up博客搭建","slug":"computer-science计算机技术/blog-set-up博客搭建","permalink":"https://linh47.github.io/categories/computer-science计算机技术/blog-set-up博客搭建/"}],"tags":[{"name":"Google","slug":"Google","permalink":"https://linh47.github.io/tags/Google/"},{"name":"search engine","slug":"search-engine","permalink":"https://linh47.github.io/tags/search-engine/"},{"name":"blog","slug":"blog","permalink":"https://linh47.github.io/tags/blog/"}]},{"title":"在hueman上应用博客评论插件gitalk","slug":"博客评论插件gitalk","date":"2019-03-13T08:53:42.000Z","updated":"2019-03-18T09:35:01.608Z","comments":true,"path":"2019/03/13/博客评论插件gitalk/","link":"","permalink":"https://linh47.github.io/2019/03/13/博客评论插件gitalk/","excerpt":"介绍在hueman主题的博客中欧应用gitalk评论插件的方法。","text":"介绍在hueman主题的博客中欧应用gitalk评论插件的方法。 Hueman主题已经封装好了很多评论插件，直接在配置文件中设置就好。 gitalk插件是在博客对应的github仓库下创建对应的issue作为评论，评论者只需要登录自己的github就可以评论，所以需要仓库管理者设置好网站对应github的登录认证权限。 第一次打开文章的时候评论区加载比较慢，因为正在github上创建issue。 1、设置github认证https://github.com/settings/applications/1029202 创建新app，Homepage URL和Authorization callback URL都必须是一样的，目前用的是github的博客地址https://linh47.github.io/ 保存Client ID和Client Secret，配置的时候需要用到。 2、打开hueman主题的配置文件,设置Gitalk对应的属性gitalk: on: true # enter true to enable gitalk owner: linh47 # GitHub user name repo: linh47.github.io # GitHub repository name client_id: 填自己的 # OAuth application client id client_secret: 填自己的 # OAuth application client secret admin: linh47 # GitHub repo owner and collaborators who can initialize github issues # Can either be a string or an array. 3、部署​ 在本地服务器上是没办法测试评论功能的，要部署到github以后才能测试。因为登录的时候会发送请求到你填写的回调地址，也就是博客地址。本地服务器是访问不了的。 ​ 目前发现第一次评论要管理员先登录。","categories":[{"name":"computer science计算机技术","slug":"computer-science计算机技术","permalink":"https://linh47.github.io/categories/computer-science计算机技术/"},{"name":"blog set up博客搭建","slug":"computer-science计算机技术/blog-set-up博客搭建","permalink":"https://linh47.github.io/categories/computer-science计算机技术/blog-set-up博客搭建/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://linh47.github.io/tags/blog/"},{"name":"hueman","slug":"hueman","permalink":"https://linh47.github.io/tags/hueman/"},{"name":"gitalk","slug":"gitalk","permalink":"https://linh47.github.io/tags/gitalk/"}]}]}