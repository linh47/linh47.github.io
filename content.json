{"meta":{"title":"小哀的安眠岛","subtitle":"想要听你说 你看见的光 是我","description":null,"author":"Linh","url":"https://linh47.github.io","root":"/"},"pages":[{"title":"关于我","date":"2019-03-13T05:37:23.000Z","updated":"2019-03-13T07:35:04.084Z","comments":true,"path":"about/index.html","permalink":"https://linh47.github.io/about/index.html","excerpt":"","text":"2017级中南大学CS研究生在读。女的。 联系邮箱：linh47@163.com ​ 【有问题再发邮件哇！】 最喜欢java，但不止于java。喜欢开发各种新技能。 这个博客希望能输出一些干货，废话就不在这儿说啦。 日常BB在豆瓣。不太擅长给自己贴标签，是个随心所欲的家伙。人生要义是开心。"},{"title":"categories","date":"2019-03-13T06:17:44.000Z","updated":"2019-03-13T07:06:42.444Z","comments":true,"path":"categories/index.html","permalink":"https://linh47.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Java并发编程（多线程）","slug":"Java并发编程（多线程）","date":"2019-03-18T04:32:09.107Z","updated":"2019-03-18T09:28:32.539Z","comments":true,"path":"2019/03/18/Java并发编程（多线程）/","link":"","permalink":"https://linh47.github.io/2019/03/18/Java并发编程（多线程）/","excerpt":"","text":"Java并发编程（多线程）运行中的程序就是进程，进程内部可以包含多个线程（顺序执行流） 具体例子：打开QQ、浏览器，等于开了2个进程，然后QQ里的任务可以交给多个线程执行，浏览器也是。 一、并发与并行并发：​ 同一时刻只有一条指令执行 并行：​ 同一时刻有多条指令在不同的处理器上同时执行 二、线程与进程进程的概念和特征 进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。 进程是处于运行过程中的程序，是系统进行资源分配和调度的一个独立单位。 独立性： ​ 独立存在，独立资源，私有的地址空间。 动态性： ​ 正在系统中活动的指令集合，与时间有关，有生命周期和状态。 并发性： ​ 多个进程可以在单个CPU上并发执行，进程之间不会相互影响。 ​ 并发时，CPU不断地轮换执行进程，多个进程指令被快速地轮换执行，宏观上达到多个进程同时执行的效果。 进程与程序的区别进程是正在执行的程序，是正在系统中活动的指令集合。进程是动态的，有自己的生命周期和不同的状态。程序只是静态的指令集合。 线程的概念 线程，有时被称为轻量级进程(Lightweight Process，LWP），是程序执行流的最小单元。线程是程序中一个单一的顺序控制流程。进程内一个相对独立的、可调度的执行单元，是系统独立调度和分派CPU的基本单位指运行中的程序的调度单位。在单个程序中同时运行多个线程完成不同的工作，称为多线程。 一个进程至少有一个主线程，可以有多个线程。进程负责调度和管理线程。 线程是进程的组成部分/执行单元。线程是独立的、并发的执行流。 线程可以拥有自己的堆栈、程序计数器、局部变量，但是不拥有系统资源。 线程不拥有系统资源，它们共享父进程拥有的全部资源。比如内存、文件句柄和其他进程的状态。 每个线程都有自己的父进程。一个线程可以创建和撤销另一个线程。 线程运行的时候不知道其他线程是否存在。线程的执行是抢占式的。 使用多线程的好处 ​ 创建线程的代价比创建进程小得多，创建进程要分配内存和资源 ​ 同一进程的线程之间可以共享资源，线程间的通信开销也可以小，实现多任务的并发效率更高 ​ 减少了等待IO操作处理的时间，资源利用率更高 ​ Java语言内置了多线程功能的支持，简化了多线程编程 使用多线程的代价 ​ 程序更加复杂，需要更加注意线程之间的交互，不正确的线程同步会产生错误 ​ CPU在做上下文切换时也有开销 挂起一个进程 恢复一个进程 跳转到程序计数器所指向的位置 ​ 管理线程也要消耗资源（可以通过线程池缓解） #### 三、线程的创建 继承Thread类 实现Runnable接口 实现Callable接口（可以有返回值、抛出异常） 注：实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以说任务是通过线程驱动从而执行的。 我的理解：所有的线程对象都必须是Thread类/其子类 的实例 创建线程的方式对比 实现接口的优缺点 Java 不支持多重继承，但是可以实现多个接口；线程类只是实现了接口的话，还可以继承其他类。 多个线程可以共享一个target对象，适合多个相同线程处理同一份资源的情况 编写程序会比较复杂，访问当前线程只能用Thread.currentThread()方法 继承Thread类的优缺点 不能再继承其他父类 编写简单，直接使用this可以获得当前线程 1、继承Thread类，创建线程类12345678910111213141516public class FirstThread extends Thread&#123; private int i;//这个变量不可以被多个线程共享 public void run() &#123; //线程执行体，也就是线程要执行的任务 //想获取当前线程，可以直接用this &#125;&#125;public static void main(String[] args)&#123; new FirstThread().start(); //start是启动线程，然后会调用线程的run方法。 new FirstThread().start(); //这样会启动另一个线程&#125; 注意：程序运行时会创建一个主线程，主线程的线程执行体就是main方法，然后再创建显式定义的其他线程。 ​ 使用继承Thread类来创建线程时，多个线程之间无法共享线程类的实例变量。 ​ 我的理解：因为每个线程都是继承Thread线程类（比如这个例子就是FirstThread）的一个线程对象启动的（new FirstThread()），一个线程对应了一个对象，所以他们的实例变量不是同一个对象的，就没法共享。 2、实现Runnable接口，创建线程类 123456789101112131415161718192021public class SecondThread implements Runnable&#123; private int i;//这个变量可以被2个线程共享 public void run() &#123; //线程执行体，也就是线程要执行的任务 //想获取当前线程，只能调用Thread.currentThread()方法 &#125;&#125;public static void main(String[] args)&#123; //注意与继承Thread类的对象创建进行区分 //先创建线程类的对象 SecondThread st=new SecondThread(); //再以线程类的对象作为Thread类的target，创建真正的线程对象 //也就是说，线程对象一定得是Thread类/其子类 的实例 //我们实现接口的类不能作为线程对象去启动线程 new Thread(st,\"线程1\").start(); //start是启动线程，然后会调用线程的run方法。 new Thread(st,\"线程2\").start();&#125; 注意：这个时候，因为2个线程实际上都是用同一个线程类（SecondThread）做target来创建线程对象的，所以线程1和线程2是共享线程类（SecondThread）的实例变量的。 ​ 我的理解：多个线程可以共享同一个target，也就是可以共享target对应类的实例变量。 Java 8开始，Runnable接口是函数式接口，可以用Lambda表达式创建Runnable对象。 3、使用Callable和Future创建线程Callable接口可以看做Runnable接口的增强版，它提供的call()方法也可以作为线程执行体，但是功能更强大。它是Java 5新增的接口，也是函数式接口。 call()方法： ​ 有返回值 ​ 可以声明抛出异常 但是，Callable接口不是Runnable接口的子接口，它不可以直接作为Thread的target。 Future接口也是Java 5新增的，它代表Callable接口的call()方法的返回值。 FutureTask是Future接口的实现类，它还实现了Runnable接口。 所以——FutureTask 可以作为Thread类的target，又能获取到callI()方法的返回值。 FutureTask 常用方法 cancel(boolean xxx) get() 阻塞直到子线程结束得到返回值 get(long timeout,TimeUnit unit) 限时阻塞，超时抛出TimeoutException异常 isCancelled() isDone() 创建、启动、使用有返回值的线程的步骤如下： 12345678910111213141516171819202122232425262728public class ThirdThread &#123; public static void main(String[] args) &#123; //先创建Callable对象 ThirdThread rt=new ThirdThread(); //使用Lambda创建Callable&lt;Integer&gt;对象 //使用FutureTask包装Callable对象 //参数的泛型类型必须和返回值类型对应，包装类 FutureTask&lt;Integer&gt; task=new FutureTask&lt;Integer&gt; ( (Callable&lt;Integer&gt;)()-&gt; &#123; int i=0; //线程执行体 return i; &#125;); //以包装后的Callable对象作为Thread的target创建、启动线程 new Thread(task,\"线程3\").start(); //可以用FutureTask类的get方法获取线程执行体的返回值，get方法可以抛出超时异常。 try &#123; System.out.println(\"子线程的返回值\"+task.get()); &#125;catch(Exception ex) &#123; ex.printStackTrace(); &#125; &#125;&#125; 四、线程的生命周期因为一个线程不可能一直霸占CPU运行，所以CPU会切换线程，就会有线程的不同状态的转换。 线程的状态（5种） 新建 new new完，虚拟机分配内存，初始化成员变量的值 就绪（可运行） runnable 调用了start()方法，虚拟机创建方法调用栈和程序计数器。表示线程可以运行了。 但是未必马上就开始执行线程，而是要等待CPU。 要立刻执行的话，可以让当前运行的线程sleep一毫秒，让CPU执行这个就绪的线程。 只能对new状态的线程调用start()方法，否则引发IllegalThreadStateException异常。（对同一个线程调用2次start()同理） 运行 running 线程获得了CPU，开始执行run()方法。 单CPU，一个时刻只有一个线程处于运行状态。 多CPU，多个线程并行执行。如果线程数比CPU数多，依然会存在线程在一个CPU上轮换的现象。 线程不可能一直处于运行状态，除非它瞬间就执行结束了。线程需要被中断，让给其他线程执行。 根据系统策略不同，调度细节也不同。 抢占式策略的系统（桌面/服务器端系统），每个线程被分配固定的时间段，用完了资源就被剥夺，其他线程被执行。 协作式调度策略的系统（手机系统），每个线程主动放弃所占用的资源，调用sleep()或者yield()方法。 阻塞 blocked 发生如下情况，线程会进入阻塞状态： ​ 调用sleep()方法 ​ 调用阻塞式IO方法，在方法返回前都处于阻塞状态 ​ 线程试图获得一个同步监视器，但该监视器被其他线程所持有。 ​ 线程在等待某个通知notify ​ 程序调用了suspend()方法将线程挂起（容易导致死锁，避免使用） 阻塞的线程被解除后可以进入就绪状态，必须等待再次调度才能运行。 解除阻塞状态： ​ 调用sleep()的线程经过了指定时间 ​ 阻塞式IO方法已经返回 ​ 线程已经获得了同步监视器 ​ 线程在等待通知时，其他线程发出了通知 ​ 处于挂起状态的线程被调用了resume()方法恢复 死亡 dead 线程结束后就处于死亡状态 结束的方式： ​ run()或者call()方法执行完成 ​ 线程抛出一个未捕获的exception或error ​ 直接调用线程的stop()方法（容易导致死锁，不建议使用） 注意，子线程不受主线程结束的影响，不会随着它结束。 死亡的线程就不要再调用start()启动它了。否则会引发IllegalThreadStateException异常。 调用isAlive()方法，可以测试线程是否死亡 就绪、运行、阻塞时返回true，新建、死亡时返回false。 我的理解：线程不能进入运行的状态就算它不是活着的，新建的时候它还不能直接变成运行。 测试isAlive()代码 12345678910111213141516171819202122232425262728public class TwoThreadAlive extends Thread&#123; public void run() &#123; for (int i = 0; i &lt; 5; i++) &#123; printMsg(); System.out.println(\"for in run\"); &#125; System.out.println(\"The end of run(), tt.isAlive()=\" + Thread.currentThread().isAlive()); &#125; public void printMsg() &#123; Thread t = Thread.currentThread();//获取当前的线程对象 String name = t.getName(); System.out.println(\"name=\" + name); &#125; public static void main(String[] args) &#123; TwoThreadAlive tt=new TwoThreadAlive(); tt.setName(\"ThreadObject\"); System.out.println(\"after new,before start(), tt.isAlive()=\" + tt.isAlive()); System.out.println(\"start()\"); tt.start(); System.out.println(\"just after start(), tt.isAlive()=\" + tt.isAlive()); for (int i = 0; i &lt; 5; i++) &#123; System.out.println(\"for in main，current Thread is:\"+Thread.currentThread().getName()); &#125; tt.printMsg();//注意这一行，实际上是main线程执行了printMsg()方法 System.out.println(\"The end of main(), tt.isAlive()=\" + tt.isAlive()); &#125;&#125; 输出结果（每次顺序会有小小区别） 123456789101112131415161718192021after new,before start(), tt.isAlive()=falsestart()just after start(), tt.isAlive()=truefor in main，current Thread is:mainfor in main，current Thread is:mainfor in main，current Thread is:mainfor in main，current Thread is:mainfor in main，current Thread is:mainname=mainname=ThreadObjectfor in runThe end of main(), tt.isAlive()=truename=ThreadObjectfor in runname=ThreadObjectfor in runname=ThreadObjectfor in runname=ThreadObjectfor in runThe end of run(), tt.isAlive()=true 从结果可以明显地看出两点： 1、刚new的线程isAlive是false 2、main方法结束，子线程要执行完再结束 我的理解：在main方法中再调用子线程对象的实例方法，实际上还是main线程去执行方法。 tt.printMsg();//注意这一行，实际上是main线程执行了printMsg()方法 输出的是name=main。 从整个输出语句看，主线程的for循环和子线程的run方法是轮换执行的。可以看到main线程还要执行一次tt对象的printMsg()方法。 我的疑惑：主线程什么时候死亡？是main方法运行完就死亡吗？还是主线程要在后台做完其他工作再死亡？ 我的解答： ​ 需要区分守护线程和非守护线程。 ​ 守护线程是JVM自己要用的线程，用来实现GC、监视等。其他的都算非守护进程，包括主线程。 ​ 程序运行的时候会先创建守护线程。然后创建主线程，主线程找main方法，调用main方法。 ​ 默认情况下，main方法里面创建的都是非守护进程。对于CPU来说，主线程也是个线程。所以主线程的结束不影响其他线程。所以主线程是有可能先结束，进入死亡状态的。 ​ JVM等所有非守护进程执行结束，然后退出。当 JVM 退出时，所有仍然存在的守护线程都将被抛弃，既不会执行 finally 部分的代码，也不会执行 stack unwound 操作，JVM 会直接退出。 ​ 可以设置一个线程为守护线程，Thread.setDaemon(true); ，也就是它执不执行完JVM都会照常关闭，JVM不再等它。 新的线程是否初始为守护线程，取决于启动该线程的线程是否为守护线程。 守护线程默认启动的线程为守护线程，非守护线程启动的线程默认为非守护线程。 主线程（非守护线程）启用一个守护线程，需要调用Thread.setDaemon来设置启动线程为守护线程。","categories":[{"name":"IT技术","slug":"IT技术","permalink":"https://linh47.github.io/categories/IT技术/"},{"name":"Java","slug":"IT技术/Java","permalink":"https://linh47.github.io/categories/IT技术/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://linh47.github.io/tags/Java/"},{"name":"Thread","slug":"Thread","permalink":"https://linh47.github.io/tags/Thread/"},{"name":"多线程","slug":"多线程","permalink":"https://linh47.github.io/tags/多线程/"},{"name":"进程","slug":"进程","permalink":"https://linh47.github.io/tags/进程/"},{"name":"并发","slug":"并发","permalink":"https://linh47.github.io/tags/并发/"}]},{"title":"论文笔记-LPAwb+和DIRTLPAwb+","slug":"论文笔记-LPAwb+和DIRTLPAwb+","date":"2019-03-17T13:43:56.454Z","updated":"2019-03-18T09:26:54.229Z","comments":true,"path":"2019/03/17/论文笔记-LPAwb+和DIRTLPAwb+/","link":"","permalink":"https://linh47.github.io/2019/03/17/论文笔记-LPAwb+和DIRTLPAwb+/","excerpt":"","text":"Beckett S J. Improved community detection in weighted bipartite networks[J]. Royal Society open science, 2016, 3(1): 140536. 概述：​ 这篇论文于2016年发表于 Royal Society open science（impact factor 2.5)。 ​ 论文改进了LPAb+算法（LPAb+改进自LPA标签传播算法），用于二分加权网络上的社区划分。作者Beckett 提出了LPAwb+和DIRTLPAwb+两种算法。其中DIRTLPAwb+是对LPAwb+的使用改进算法。 ​ 所用数据集： 生成网络（800个）【QuanBiMo、LPAwb+、DIRTLPAwb+在每个网络上跑一次，取最好结果】 ​ 生成参数： ​ 行节点数30 列节点数50 ​ 社区数 2或10 ​ 社区边权重随机，服从偏态负二项分布 （skewed negative binomial distribution） ​ 分散参数 (0.5,2.5)，平均值为4 ​ 噪声noise=0,0.01,0.25,0.5 23种plant-pollinator网络【LPAwb+、DIRTLPAwb+在每个网络上跑100次，取最好结果】 ​ 下载地址： ​ https://www.nceas.ucsb.edu/interactionweb/resources.html#plant_pollinator ​ 论文LPAwb+源代码： ​ https://github.com/sjbeckett/weighted-modularity-LPAwbPLUS ​ 对比算法： ​ QuanBiMo ​ 评价指标： ​ 检测出的社区数占已知社区数的比率 ​ 改进的模块度 ​ NMI 亮点：​ 模块度改进了Barber’s Modularity，使其适用于加权二分网络。 ​ LPAwb+速度快，适用于大型网络。 ​ DIRTLPAwb+虽然也依赖输入参数，但是它的参数比QuanBiMo更有意义，表现更稳定，而且结果不比LPAwb+差。 一句话总结： ​ LPAwb+容易陷入次最优化的情况，它也依赖于初始化的标签，但他的速度占优势。 ​ DIRTLPAwb+从miu个标签中随机选择作为初始化标签，计算了多次LPAwb+，返回最好的结果。速度肯定比单次LPAwb+慢，但是表现接近LPAwb+，优于QuanBiMo。 ​ LPAwb+和DIRTLPAwb+都受网络的社区数的影响，也受社区之间节点连接程度的影响。 详解QuanBiMo ​ 第一个考虑权重的适用于二分网络的基于最大化模块度的社区发现算法 ​ 在多层随机网络上使用模拟退火算法 LPAb+ ​ 标签传播算法+多步合并。时间复杂度小，社区发现结果较好，但是没考虑权重。 模块度 Barber’s Modularity 二分网络的两种不同类型的节点可以分在同一个社区。 ​ 注：Guimera’s模块度就是不同类的节点不会划分到一个社区中。 ​ 公式： 改进的适用于加权网络的Barber’s Modularity ​ 用来跟其他算法做比较而标准化的模块度 二分网络和加权网络都能用的模块度","categories":[{"name":"搞学术","slug":"搞学术","permalink":"https://linh47.github.io/categories/搞学术/"},{"name":"复杂网络-社区发现","slug":"搞学术/复杂网络-社区发现","permalink":"https://linh47.github.io/categories/搞学术/复杂网络-社区发现/"}],"tags":[{"name":"复杂网络","slug":"复杂网络","permalink":"https://linh47.github.io/tags/复杂网络/"},{"name":"社区发现","slug":"社区发现","permalink":"https://linh47.github.io/tags/社区发现/"},{"name":"二分网络","slug":"二分网络","permalink":"https://linh47.github.io/tags/二分网络/"},{"name":"complex networks","slug":"complex-networks","permalink":"https://linh47.github.io/tags/complex-networks/"},{"name":"bipartite networks","slug":"bipartite-networks","permalink":"https://linh47.github.io/tags/bipartite-networks/"},{"name":"community detection","slug":"community-detection","permalink":"https://linh47.github.io/tags/community-detection/"},{"name":"LPA","slug":"LPA","permalink":"https://linh47.github.io/tags/LPA/"}]},{"title":"给博客加上背景音乐吧","slug":"给博客加上背景音乐吧","date":"2019-03-13T17:05:23.000Z","updated":"2019-03-13T17:53:42.454Z","comments":true,"path":"2019/03/14/给博客加上背景音乐吧/","link":"","permalink":"https://linh47.github.io/2019/03/14/给博客加上背景音乐吧/","excerpt":"","text":"我是一个很爱听随机歌的人，没有歌总觉得少了什么。 于是给博客加上了播放器~~~ 查了一下，侧边栏是通过网易云的外链播放器iframe实现的，文章内则靠hexo的两个插件实现。 1、侧边栏播放器增加BGM栏，步骤跟其他的widget差不多 hueman的配置文件12widgets:- mymusic zh-CN加上翻译1mymusic: &apos;背景音乐&apos; layout的widget里面加ejs文件12345678&lt;% if (site.tags.length) &#123; %&gt; &lt;div class=&quot;widget-wrap widget-list&quot;&gt; &lt;h3 class=&quot;widget-title&quot;&gt;&lt;%= __(&apos;BGM&apos;) %&gt;&lt;/h3&gt; &lt;div class=&quot;widget&quot;&gt; &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=300 height=450 src=&quot;//music.163.com/outchain/player?type=0&amp;id=884698131&amp;auto=1&amp;height=430&quot;&gt;&lt;/iframe&gt; &lt;/div&gt; &lt;/div&gt;&lt;% &#125; %&gt; 重点就是ejs文件里的啦，这个生成非常简单。 打开网易云音乐的网页版，找到喜欢的单曲或者歌单，只要不收钱的不要版权的都可以导出外链播放器。 选择iframe形式的，自己选个大小，稍微调一下就可以复制到自己的ejs文件里啦。 我的大小是300宽，450高。auto=1是自动播放，0就是手动播放。 有的能生成播放器的也未必播放得了，在网易云插件就可以试出来。 2、文章内播放器使用hexo的插件hexo-tag-aplayer ​ 安装 1npm install --save hexo-tag-aplayer ​ 可以把音乐放到之前提到过的文章的资源文件夹里，有相对路径可以引用 1&#123;% aplayer &quot;如常&quot; &quot;房东的猫&quot; &quot;房东的猫-如常.flac&quot; &quot;ruchang.jpg&quot; &quot;lrc:房东的猫-如常.lrc&quot; %&#125; [00:00.00] 作曲 : 少年佩 [00:01.00] 作词 : 一只然 [00:11.10]制作人/编曲/弦乐编写 : 樊哲忠 [00:13.24]监制 : 李纤橙 [00:14.74]主唱/和声 : 红鼻子小黑 [00:16.44]弦乐 : 国际首席爱乐团 [00:17.93]打击乐 : 陳柏州 [00:19.03]录音师 : 汝文博 [00:20.23]录音室 : BIG J Studio Beijing [00:21.53]混音師 : 赵靖 [00:31.90]很多时候你一个人习惯了 [00:35.94]就无法给与嘱托 [00:40.53]你习惯了如风般不结伴穿梭 [00:46.37]影子都没留片刻 [00:52.53]很多时候你一个人常常是 [00:56.12]只考虑一个人的 [01:00.91]你独舞喜怒哀乐任光阴如何 [01:06.35]任光阴如何收割 [01:13.23]你就是如此令人神往的角色 [01:17.97]在造物主的手中不拘一格 [01:23.41]锋利中带着柔和 [01:27.90]柔和里伴随冷落 [01:33.49]你就有如此不可多得的神色 [01:37.83]你每种表情无需费力把我俘获 [01:44.56]平静里带着谴责 [01:47.90]谴责却没有愠火 [02:10.45]很多时候你一个人厌倦了 [02:14.39]序列有秩的生活 [02:19.13]你厌倦同一班车被夕阳吞没 [02:24.72]却怨的不动声色 [02:34.15]很多时候你一个人就这么 [02:38.69]跳入了一扇沉默 [02:44.08]看起来属于陌生或属于暮色 [02:49.66]却不是属于谁的 [02:57.45]你就是如此令人神往的角色 [03:01.14]在造物主的手中不拘一格 [03:07.02]锋利中带着柔和 [03:11.46]柔和里伴随冷落 [03:17.25]你就有如此不可多得的神色 [03:21.39]你每种表情无需费力把我俘获 [03:28.08]平静里带着谴责 [03:31.17]谴责却没有愠火 [04:17.40]你就是如此令人神往的角色 [04:22.44]在造物主的手中不拘一格 [04:27.88]锋利中带着柔和 [04:32.32]柔和里伴随冷落 [04:37.80]你就有如此不可多得的神色 [04:42.39]你每种表情无需费力把我俘获 [04:48.73]平静里带着谴责 [04:52.07]谴责却没有愠火 [04:58.26]你告别该有的脆弱 [05:03.15]你放生无罪的困惑 [05:08.19]你沿着真心一路上 [05:11.78]化作未染的清澈 var ap = new APlayer({ element: document.getElementById(\"aplayer-TnlKjJgD\"), narrow: false, autoplay: false, showlrc: 2, music: { title: \"如常\", author: \"房东的猫\", url: \"房东的猫-如常.flac\", pic: \"/2019/03/14/给博客加上背景音乐吧/ruchang.jpg\", lrc: \"房东的猫-如常.lrc\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 《如常》我是买了的啦~~~强烈安利房东的猫，虽然现在已经不算小众了哈哈哈。听现场唱歌好舒服啊啊啊~两个妹子都是干干净净非常美好。","categories":[{"name":"IT技术","slug":"IT技术","permalink":"https://linh47.github.io/categories/IT技术/"},{"name":"博客","slug":"IT技术/博客","permalink":"https://linh47.github.io/categories/IT技术/博客/"}],"tags":[{"name":"BGM","slug":"BGM","permalink":"https://linh47.github.io/tags/BGM/"},{"name":"网易云音乐","slug":"网易云音乐","permalink":"https://linh47.github.io/tags/网易云音乐/"}]},{"title":"hexo使用本地图片","slug":"hexo使用本地图片","date":"2019-03-13T14:25:30.000Z","updated":"2019-03-13T14:34:30.975Z","comments":true,"path":"2019/03/13/hexo使用本地图片/","link":"","permalink":"https://linh47.github.io/2019/03/13/hexo使用本地图片/","excerpt":"","text":"1、hexo的配置文件post_asset_folder:true 意思是每新建一个文档，就生成一个文件夹用来放对应的资源 2、下载插件在hexo的目录下执行npm install https://github.com/CodeFalling/hexo-asset-image --save 3、图片放在文档的文件夹下4、在MD文档中引用本地图片其实使用的是hexo的标签 1&#123;% asset_img wallhaven-681094.png 壁纸示例%&#125;","categories":[{"name":"IT技术","slug":"IT技术","permalink":"https://linh47.github.io/categories/IT技术/"},{"name":"博客","slug":"IT技术/博客","permalink":"https://linh47.github.io/categories/IT技术/博客/"}],"tags":[]},{"title":"教你一天搭建一个免费的个人博客","slug":"教你一天搭建一个免费的个人博客","date":"2019-03-13T09:40:11.871Z","updated":"2019-03-13T09:55:48.085Z","comments":true,"path":"2019/03/13/教你一天搭建一个免费的个人博客/","link":"","permalink":"https://linh47.github.io/2019/03/13/教你一天搭建一个免费的个人博客/","excerpt":"","text":"前言​ 不知道你们有没有跟我一样的感觉，我想总结学到的东西和经验，通过写作练习正确表达自己的想法，教别人的同时也会逼着自己去学懂一件事情；也不是作为自媒体想运营获得收入或者出名，只是想记录一些比较私人化的东西。 怀着一腔鸡血，结果我发现没有合适的平台可以自由地写作。 社恐患者其实也很怕没有意义的互动，对点赞转发评论的回复是很耗费精力的。 创建自己的公众号太麻烦，填许多资料还要每年交300块保护费，公众号内容还需要被审核，一些想法被平时熟悉的人知道也有点不好意思。 普通的博客平台比如CSDN、新浪等，社交性太强，有大量广告和自由度有限的博客模板。 昨天搜到了github Pages，发现经过不是非常复杂的操作，就能拥有一个免费、无限流量、还能部分自定义网址（前缀）又不需要购买域名和域名备案的个人博客。实际上Github Pages能实现的不仅仅是博客，简直就可以作为你的个人网站来使用。你可以控制它看起来是什么样子，有许多好看的主题可以挑选，功能块自己能够定义，也可以充满安全感地写作。 你所需要的不过是跟着教程一步步做下来，就能得到你的个人博客啦。 如果你感兴趣的话，就继续看吧。 需要一点点计算机操作的基础，比如cmd命令行怎么用，如何科学地打开你想要的网站，如何在官方渠道下载安全的安装软件，如何使用git和github。这些都很容易搜到的。 所需工具 GitHub Pages Nodejs npm Hexo Typora 主要步骤 https://pages.github.com/ 跟着官方流程把github Pages搭好。 https://hexo.io/zh-cn/ 跟着官方教程下载所需的组件，安装hexo。 使用hexo进行对应页面的创建。 安装好hexo对应的git插件。 使用hexo部署到你的github pages。 使用Typora进行MD文档的编辑。 Hexo部分hexo的配置文件yaml格式非常严格，空格不能少，也必须是英文。编码必须是UTF-8，不能带BOM。 修改yaml部分用notepad++。 记录一下部署的配置格式，每个冒号后面必须跟一个空格。 1234deploy: type: git repository: https://github.com/linh47/linh47.github.io.git branch: master Hexo常用命令： 含义 命令 简写 新建文档或页面 hexo new [page] “标题” hexo n xxx 清除已经生产的静态页面（public文件夹） hexo clean hexo c 重新生成静态页面 hexo generate hexo g 启动本地服务器 hexo server hexo s 部署到远程服务器(github) hexo deploy hexo d 主题部分hexo提供了多样化的主题可供选择。https://hexo.io/themes/ 我喜欢的是hueman主题。以下是设置主题的参考。 Hueman主题官方文档：https://github.com/ppoffice/hexo-theme-hueman/wiki 可参考文档：https://arvinsir.com/2017/05/19/hexo-themes-hueman/ 使用步骤 clone到hexo的theme文件夹下。 https://github.com/ppoffice/hexo-theme-hueman.git hexo的配置文件中theme 改成hueman。 修改hueman的配置文件，刚clone的后缀.example要删掉。 配置主题 ​ 修改语言：hexo的配置文件中 language改成zh-CN ​ 修改页面头、脚：hueman/source/css/_partial/header.styl和footer.styl文件 。 ​ 图片路径：hueman/source/css/images ​ logo大小：hueman的配置文件中 12345customize: logo: width: 165 height: 60 url: images/logo-header.png ​ 显示网站访问量： ​ 在hueman/layout/common/footer.ejs添加两句。注意编码！utf-8。 1&lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 12&lt;span id=&quot;busuanzi_container_site_pv&quot;&gt;本站总访问量为：&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt; 配置网站的语言 ​ hueman的配置文件中全部写英文，在language文件夹下的zh-CN.yml增加对应的中文翻译。 ​ 123456789index: home: &apos;主页&apos; about: &apos;关于&apos; search: &apos;搜索&apos; archive: &apos;归档&apos; category: &apos;分类&apos; uncategorized: &apos;未分类&apos; tag: &apos;标签&apos; lifestyle: &apos;生活方式&apos; 网站的菜单与目录： hexo的配置文件中有category_dir: categories。hexo下面的source有categories文件夹就可以。 **hueman的配置里，菜单项就不用一个个写了！！！hueman的菜单栏应该不包括文章的具体分类项。 文章直接在开头写categories和tags就可以了！ 文章的分类（hueman最多支持2级）和标签 在MD文件的最前面加 12345678---title: 博客是怎么从0到1的date: 2019-03-12 21:58:36tags: blogcategories: - ittech - blog--- 补充： 在站点目录 /scaffolds/post.md 文件中添加一项categories，这样每次新建博客文章 new 出来的 .md 文件就都带 categories 了 如果generate报错，用notepad++打开MD检查开头的格式。 在typora软件里面，— 和 — 会自动省略，显示成灰色的就可以了，不用再手动加上去。","categories":[{"name":"IT技术","slug":"IT技术","permalink":"https://linh47.github.io/categories/IT技术/"},{"name":"博客","slug":"IT技术/博客","permalink":"https://linh47.github.io/categories/IT技术/博客/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://linh47.github.io/tags/blog/"},{"name":"hueman","slug":"hueman","permalink":"https://linh47.github.io/tags/hueman/"},{"name":"hexo","slug":"hexo","permalink":"https://linh47.github.io/tags/hexo/"},{"name":"github pages","slug":"github-pages","permalink":"https://linh47.github.io/tags/github-pages/"}]},{"title":"让谷歌检索到你的个人博客","slug":"让谷歌检索到你的个人博客","date":"2019-03-13T09:16:16.000Z","updated":"2019-03-13T09:32:13.673Z","comments":true,"path":"2019/03/13/让谷歌检索到你的个人博客/","link":"","permalink":"https://linh47.github.io/2019/03/13/让谷歌检索到你的个人博客/","excerpt":"","text":"刚搭建完博客能够访问的时候，我以为随便百度谷歌都能搜到我写的东西了，屁颠屁颠搜了下，一点相关的都没有，然后看了教程才知道，想让自己的网站被检索，还需要上谷歌填写资料。 检查是否被收录的方法： 方法：打开百度或谷歌搜索，在搜索框里输入 1site:你的博客地址 如果显示 尝试使用 Google Search Consolewww.google.com/webmasters/ 您对 linh47.github.io 是否具有所有权？请从 Google 获取索引和排名数据。 就是还不能被搜索引擎检索到呢。 那么记录一下怎样让谷歌检索到自己个人博客的方法吧！ 1、生成自己网站的站点地图这个站点地图很多地方都要用到，值得一做。 先安装自动生成插件 12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 在hexo的配置文件中添加 12345# 自动生成sitemapsitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml 配置好了以后执行一下 hexo g，就能在博客文件\\public目录下找到中生成的sitemap.xml和baidusitemap.xml了。 2、提交网站信息，设置html的meta标记你想让谷歌检索你的博客，首先要证明这个网站你有所有权，也就是你可以更改网站的内容。 有几种验证方法，由于hexo经常会把生成的静态文件clean掉，所以我们用在主题的头文件中添加html的meta标记的方法，一劳永逸。 https://www.google.com/webmasters/ https://ziyuan.baidu.com/site 先跟着网址指引一步步填写信息。 然后复制网址提供给你验证的meta html的meta放在hueman里面的head.ejs文件里面哦。 填好以后要先重新部署才能进行验证。 3、验证所有权后就可以提交站点地图站点地图的意义在于搜索引擎能够更好地抓取网站的内容。 根据对应搜索引擎的提示，谷歌提交sitemap.xml，百度提交baidusitemap.xml就可以了。 4、检索生效期都设置好了以后并不能马上就搜到自己的博客内容，因为要等搜索引擎更新他的索引。","categories":[{"name":"IT技术","slug":"IT技术","permalink":"https://linh47.github.io/categories/IT技术/"},{"name":"博客","slug":"IT技术/博客","permalink":"https://linh47.github.io/categories/IT技术/博客/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://linh47.github.io/tags/blog/"},{"name":"Google","slug":"Google","permalink":"https://linh47.github.io/tags/Google/"},{"name":"search engine","slug":"search-engine","permalink":"https://linh47.github.io/tags/search-engine/"}]},{"title":"在hueman上应用博客评论插件gitalk","slug":"博客评论插件gitalk","date":"2019-03-13T08:53:42.000Z","updated":"2019-03-13T09:04:45.317Z","comments":true,"path":"2019/03/13/博客评论插件gitalk/","link":"","permalink":"https://linh47.github.io/2019/03/13/博客评论插件gitalk/","excerpt":"","text":"Hueman主题已经封装好了很多评论插件，直接在配置文件中设置就好。 gitalk插件是在博客对应的github仓库下创建对应的issue作为评论，评论者只需要登录自己的github就可以评论，所以需要仓库管理者设置好网站对应github的登录认证权限。 第一次打开文章的时候评论区加载比较慢，因为正在github上创建issue。 1、设置github认证https://github.com/settings/applications/1029202 创建新app，Homepage URL和Authorization callback URL都必须是一样的，目前用的是github的博客地址https://linh47.github.io/ 保存Client ID和Client Secret，配置的时候需要用到。 2、打开hueman主题的配置文件,设置Gitalk对应的属性gitalk: on: true # enter true to enable gitalk owner: linh47 # GitHub user name repo: linh47.github.io # GitHub repository name client_id: 填自己的 # OAuth application client id client_secret: 填自己的 # OAuth application client secret admin: linh47 # GitHub repo owner and collaborators who can initialize github issues # Can either be a string or an array. 3、部署​ 在本地服务器上是没办法测试评论功能的，要部署到github以后才能测试。因为登录的时候会发送请求到你填写的回调地址，也就是博客地址。本地服务器是访问不了的。 ​ 目前发现第一次评论要管理员先登录。","categories":[{"name":"IT技术","slug":"IT技术","permalink":"https://linh47.github.io/categories/IT技术/"},{"name":"博客","slug":"IT技术/博客","permalink":"https://linh47.github.io/categories/IT技术/博客/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://linh47.github.io/tags/blog/"},{"name":"gitalk","slug":"gitalk","permalink":"https://linh47.github.io/tags/gitalk/"},{"name":"hueman","slug":"hueman","permalink":"https://linh47.github.io/tags/hueman/"}]}]}